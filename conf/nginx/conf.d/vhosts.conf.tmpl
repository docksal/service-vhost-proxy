{{ $CurrentContainer := where $ "ID" .Docker.CurrentContainerID | first }}

{{/* Upstream template */}}
{{ define "upstream" }}
	{{ if .Address }}
		{{/* If we got the containers from swarm and this container's port is published to host, use host IP:PORT */}}
		{{ if and .Container.Node.ID .Address.HostPort }}

		# {{ .Container.Node.Name }}/{{ .Container.Name }}
		server {{ .Container.Node.Address.IP }}:{{ .Address.HostPort }};

		{{/* If there is no swarm node or the port is not published on host, use container's IP:PORT */}}
		{{ else if .Network }}

		# {{ .Container.Name }}
		server {{ .Network.IP }}:{{ .Address.Port }};

		{{ end }}
	{{ else if .Network }}

		# {{ .Container.Name }}
		server {{ .Network.IP }} down;

	{{ end }}
{{ end }}

{{/* HTTP/HTTPS server template */}}
{{ define "server" }}
	## HTTPS
	server {

		listen 80;
		listen 443 ssl http2;
		{{ range $host := split .Hosts "," }}

		server_name {{ $host }};

		{{ end }}

		{{ $cert := (printf "/etc/certs/custom/%s.crt" .Cert) }}
		{{ $certKey := (printf "/etc/certs/custom/%s.key" .Cert) }}

		{{/* Use custom cert if it exist */}}
		{{/* E.g. /etc/certs/custom/example.com.crt and /etc/certs/custom/example.com.key */}}
		{{ if (and (exists $cert) (exists $certKey)) }}

		ssl_certificate {{ $cert }};
		ssl_certificate_key {{ $certKey }};

		{{/* Use default self-signed cert otherwise */}}
		{{ else }}

		ssl_certificate /etc/certs/server.crt;
		ssl_certificate_key /etc/certs/server.key;

		{{ end }}

		ssl_session_cache builtin:1000 shared:SSL:10m;
		ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
		ssl_ciphers HIGH:!aNULL:!eNULL:!EXPORT:!CAMELLIA:!DES:!MD5:!PSK:!RC4;
		ssl_prefer_server_ciphers on;

		{{ if and .Host.Env.NGO_CALLBACK_HOST .Host.Env.NGO_CLIENT_ID .Host.Env.NGO_CLIENT_SECRET .Host.Env.NGO_TOKEN_SECRET .Container.Env.OAUTH_ENABLED }}
		{{ if eq .Container.Env.OAUTH_ENABLED "1" }}
		# Enable oauth
		resolver 8.8.8.8 ipv6=off;

		lua_ssl_trusted_certificate /etc/ssl/certs/ca-certificates.crt;
		lua_ssl_verify_depth        5;

		set $ngo_callback_uri       '/_oauth';
		set $ngo_callback_host      '{{ .Host.Env.NGO_CALLBACK_HOST }}';
		set $ngo_client_id          '{{ .Host.Env.NGO_CLIENT_ID }}';
		set $ngo_client_secret      '{{ .Host.Env.NGO_CLIENT_SECRET }}';
		set $ngo_token_secret       '{{ .Host.Env.NGO_TOKEN_SECRET }}';
		set $ngo_user               'unknown';
		set $ngo_email_as_user      'true';
		set $ngo_extra_validity     '0';
		set_by_lua $ngo_domain      'return os.getenv("NGO_DOMAIN")';
		set_by_lua $ngo_whitelist   'return os.getenv("NGO_WHITELIST")';
		set_by_lua $ngo_blacklist   'return os.getenv("NGO_BLACKLIST")';

		expires 0;

		add_header Google-User $ngo_user;

		location / {
			proxy_ignore_client_abort on;
			access_by_lua_file "/etc/nginx/lua/access.lua";
			proxy_pass http://{{ .Upstream }};
		{{ end }}
		{{ else }}
		location / {
			proxy_pass http://{{ .Upstream }};
		{{ end }}
		}
	}
{{ end }}

{{/* END: Variables */}}

{{/* Support Docker Compose project containers */}}

{{ $dc_containers := whereLabelExists $ "com.docker.compose.service" }}

{{ range $hosts, $containers_vhost := groupByLabel $dc_containers "io.docksal.virtual-host" }}

	{{ range $service, $containers := groupByLabel $containers_vhost "com.docker.compose.service" }}
		{{ $pr_container := $containers | first }}
		{{ $project := index $pr_container.Labels "com.docker.compose.project" }}
		{{ $upstream := (print $project "-" $service) }}

	# -------------------------------------------------- #
	# Reachable via "{{ $project }}_default" network
	upstream {{ $upstream }} {
		{{ range $container := $containers }}
			{{ $addrLen := len $container.Addresses }}

			{{ range $knownNetwork := $CurrentContainer.Networks }}
				{{ range $containerNetwork := $container.Networks }}
					{{ if eq $knownNetwork.Name $containerNetwork.Name }}
						{{/* If only 1 port exposed, use that */}}
						{{ if eq $addrLen 1 }}
							{{ $address := index $container.Addresses 0 }}
							{{ template "upstream" (dict "Container" $container "Address" $address "Network" $containerNetwork) }}
						{{/* If more than one port exposed, use the one matching VIRTUAL_PORT env var, falling back to standard web port 80 */}}
						{{ else }}
							{{/* Assume port 80 by default */}}
							{{ $port := or (index $container.Labels "io.docksal.virtual-port") "80" }}
							{{ $address := where $container.Addresses "Port" $port | first }}
							{{ template "upstream" (dict "Container" $container "Address" $address "Network" $containerNetwork) }}
						{{ end }}
					{{ end }}
				{{ end }}
			{{ end }}
		{{ end }}
		# Default disabled upstream. This prevents config errors when there are no upstreams.
		server localhost:80 down;
	}

		{{/* Get the cert name from io.docksal.cert-name container label */}}
		{{ $certName := or (index $pr_container.Labels "io.docksal.cert-name") "none" }}
		{{/* Unset certName if its value us "none" */}}
		{{ $certName := when (ne $certName "none") $certName nil }}

		{{/* Get the best matching cert by name for the vhost. */}}
		{{ $primaryHost := (index (split $hosts ",") 0) }}
		{{ $vhostCert := (closest (dir "/etc/certs/custom") (printf "%s.crt" $primaryHost)) }}

		{{/* Trim file suffix - it will be added later */}}
		{{ $vhostCert := trimSuffix ".crt" $vhostCert }}
		{{ $vhostCert := trimSuffix ".key" $vhostCert }}

		{{/* Use the cert specified on the container or fallback to the best vhost match */}}
		{{ $cert := (coalesce $certName $vhostCert) }}

		{{/* Generate HTTP/HTTPS server config */}}
		{{ template "server" (dict "Hosts" $hosts "Upstream" $upstream "Cert" $cert "Container" $pr_container "Host" $CurrentContainer) }}

	{{ end }}
	# -------------------------------------------------- #

{{ end }}

{{/* END: Support Docker Compose project containers */}}

{{/* Support standalone Docker containers */}}

{{ $d_containers := whereLabelDoesNotExist $ "com.docker.compose.service" }}

{{ range $hosts, $containers := groupByLabel $d_containers "io.docksal.virtual-host" }}

	{{ $container := $containers | first }}
	{{ $upstream := $container.Name }}

	upstream {{ $upstream }} {
		{{ $addrLen := len $container.Addresses }}

		{{ range $knownNetwork := $CurrentContainer.Networks }}
			{{ range $containerNetwork := $container.Networks }}
				{{ if eq $knownNetwork.Name $containerNetwork.Name }}
					{{/* If only 1 port exposed, use that */}}
					{{ if eq $addrLen 1 }}
						{{ $address := index $container.Addresses 0 }}
						{{ template "upstream" (dict "Container" $container "Address" $address "Network" $containerNetwork) }}
					{{/* If more than one port exposed, use the one matching VIRTUAL_PORT env var, falling back to standard web port 80 */}}
					{{ else }}
						{{/* Assume port 80 by default */}}
						{{ $port := or (index $container.Labels "io.docksal.virtual-port") "80" }}
						{{ $address := where $container.Addresses "Port" $port | first }}
						{{ template "upstream" (dict "Container" $container "Address" $address "Network" $containerNetwork) }}
					{{ end }}
				{{ end }}
			{{ end }}
		{{ end }}
		# Default disabled upstream. This prevents config errors when there are no upstreams.
		server localhost:80 down;
	}

		{{/* Get the cert name from io.docksal.cert-name container label */}}
		{{ $certName := or (index $container.Labels "io.docksal.cert-name") "none" }}
		{{/* Unset certName if its value us "none" */}}
		{{ $certName := when (ne $certName "none") $certName nil }}

		{{/* Get the best matching cert by name for the vhost. */}}
		{{ $primaryHost := (index (split $hosts ",") 0) }}
		{{ $vhostCert := (closest (dir "/etc/certs/custom") (printf "%s.crt" $primaryHost)) }}

		{{/* Trim file suffix - it will be added later */}}
		{{ $vhostCert := trimSuffix ".crt" $vhostCert }}
		{{ $vhostCert := trimSuffix ".key" $vhostCert }}

		{{/* Use the cert specified on the container or fallback to the best vhost match */}}
		{{ $cert := (coalesce $certName $vhostCert) }}

		{{/* Generate HTTP/HTTPS server config */}}
		{{ template "server" (dict "Hosts" $hosts "Upstream" $upstream "Cert" $cert "Container" $container "Host" $CurrentContainer) }}

{{ end }}

{{/* END: Support standalone Docker containers */}}
